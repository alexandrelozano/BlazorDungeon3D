@inject IResizeListener listener
@inject IConfiguration configuration
@using System.Text;
@using BlazorPro.BlazorSize;
@using Microsoft.Extensions.Configuration;
@using Microsoft.AspNetCore.Http
@using BlazorDungeon3D.Code
@inject IHttpContextAccessor httpContextAccessor
@page "/"

<PageTitle>BlazorDungeon3D</PageTitle>

<div class="mainscreen" @onkeydown="KeyDown" style="transform: scale(@CalculateTransformScale());">

    <div tabindex="0" id="viewport" style="width: @(game.viewport.vpWidth)px; height: @(game.viewport.vpHeight)px;">

        <div id="overLay"></div>

        <div class="roof"></div>
        <div class="floor"></div>

        @foreach (KeyValuePair<string, string> kvp in game.viewport.dicDispBlocks)
        {
            <div class="@kvp.Key" style="display: @kvp.Value"></div>
        }

        <div id="commandsarea">
            <div id="turnLeft" class="clickable" style="cursor: pointer; background-position: @DisableCommand("KeyQ")px 0px;" @onclick="@(e => KeyDown(new KeyboardEventArgs { Code = "KeyQ" }))"></div>
            <div id="moveUp" class="clickable" style="cursor: pointer; background-position: @DisableCommand("KeyW")px 0px;" @onclick="@(e => KeyDown(new KeyboardEventArgs { Code = "KeyW" }))"></div>
            <div id="turnRight" class="clickable" style="cursor: pointer; background-position: @DisableCommand("KeyE")px 0px;" @onclick="@(e => KeyDown(new KeyboardEventArgs { Code = "KeyE" }))"></div>
            <div id="moveLeft" class="clickable" style="cursor: pointer; background-position: @DisableCommand("KeyA")px 0px;" @onclick="@(e => KeyDown(new KeyboardEventArgs { Code = "KeyA" }))"></div>
            <div id="moveDown" class="clickable" style="cursor: pointer; background-position: @DisableCommand("KeyS")px 0px;" @onclick="@(e => KeyDown(new KeyboardEventArgs { Code = "KeyS" }))"> </div>
            <div id="moveRight" class="clickable" style="cursor: pointer; background-position: @DisableCommand("KeyD")px 0px;" @onclick="@(e => KeyDown(new KeyboardEventArgs { Code = "KeyD" }))"></div>
        </div>

        <div id="infoarea">
            <pre>   N
W  @game.compass.Draw(game.player.curDir)  E
   S    
X:@game.player.curX Y:@game.player.curY Dir:@game.player.curDir
            </pre>
        </div>

        <div id="maparea">
            <pre class="map" @onkeydown="KeyDown">
                @for (int y = game.map.mapCells.GetLength(1) - 1; y >= 0; y--)
                {
                    for (int x = 0; x < game.map.mapCells.GetLength(0); x++)
                    {
                    <span class="@game.map.mapCells[x,y].cssClass">@game.map.mapCells[x,y].character</span>        
                    }
                    @Environment.NewLine
                }
            </pre>
        </div>

    </div>

</div>

@code {

    Game game;
    Logging logging;
    BrowserWindowSize browser = new BrowserWindowSize();

    protected override async Task OnInitializedAsync()
    {
        logging = new Logging()
            {
                logFile = configuration.GetValue<string>("BlazorDungeon3D:LogFile"),
                remoteIpAddress = httpContextAccessor.HttpContext.Connection.RemoteIpAddress.ToString(),
                userAgent = httpContextAccessor.HttpContext.Request.Headers["User-Agent"].ToString()
            };

        logging.Log(string.Format("New connection from IP:{0} User-Agent:{1}", logging.remoteIpAddress, logging.userAgent), logging.logFile);

        game = new Game();

        game.viewport.UpdateViewport(game.player, game.map);
        game.map.UpdateVisibleMap(game.player.curX, game.player.curY, game.player.curDir);
        game.map.UpdateCellMap(game.player.curX, game.player.curY, game.player.curDir);
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            // Subscribe to the OnResized event. This will do work when the browser is resized.
            listener.OnResized += WindowResized;
        }
    }

    protected async void KeyDown(KeyboardEventArgs e)
    {
        if (!game.waitMovement)
        {
            game.beginWaitMovement(e.Code);
            game.Move(e.Code);
            await Task.Delay(game.speed);
            game.resetWaitMovements();
            StateHasChanged();
        }
    }

    protected string DisableCommand(string code)
    {
        return game.waitMovements[code] ? "-60" : "0";
    }

    protected async void WindowResized(object _, BrowserWindowSize window)
    {
        // Get the browsers's width / height
        browser = window;

        // We're outside of the component's lifecycle, be sure to let it know it has to re-render.
        StateHasChanged();
    }

    protected string CalculateTransformScale()
    {
        float clientWidth = 500;
        float clientHeight = 700;

        string scale = (1.0f / Math.Max(clientWidth / browser.Width, clientHeight / browser.Height)).ToString().Replace(",", ".");

        return scale;
    }
}