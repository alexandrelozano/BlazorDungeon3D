@inject IResizeListener listener
@inject IConfiguration configuration
@using System.Text;
@using BlazorPro.BlazorSize;
@using Microsoft.Extensions.Configuration;
@using Microsoft.AspNetCore.Http
@using BlazorDungeon3D.Code
@inject IHttpContextAccessor httpContextAccessor
@page "/"

<PageTitle>BlazorDungeon3D</PageTitle>

<div style="width: 448px; height: 670px; transform: scale(@CalculateTransformScale()); transform-origin: 0% 0% 0px;">

    <div tabindex="0" @onkeydown="KeyDown" id="viewport" style="width: @(game.viewport.vpWidth)px; height: @(game.viewport.vpHeight)px;">

        <div id="overLay"></div>

        <div class="roof"></div>
        <div class="floor"></div>

        @foreach (KeyValuePair<string, string> kvp in game.viewport.dicDispBlocks)
        {
            <div class="@kvp.Key" style="display: @kvp.Value"></div>
        }

    </div>

    <table class="buttonstable" @onkeydown="KeyDown" style="width: @(game.viewport.vpWidth)px;">
        <tr>
            <td rowspan="2" width="25%">
                <pre>   N
W  @game.compass.Draw(game.player.curDir)  E
   S    
X:@game.player.curX Y:@game.player.curY Dir:@game.player.curDir
                </pre>
            </td>
            <td>
                <input id="Q" type="button" disabled="@game.waitMovement" value="Q @Char.ConvertFromUtf32(8630)" class="buttonsmovement" @onclick="@(e => KeyDown(new KeyboardEventArgs { Code = "KeyQ" }))" />
            </td>
            <td>
                <input id="W" type="button" disabled="@game.waitMovement" value="W @Char.ConvertFromUtf32(8593)" class="buttonsmovement" @onclick="@(e => KeyDown(new KeyboardEventArgs { Code = "KeyW" }))" />
            </td>
            <td>
                <input id="E" type="button" disabled="@game.waitMovement" value="E @Char.ConvertFromUtf32(8631)" class="buttonsmovement" @onclick="@(e => KeyDown(new KeyboardEventArgs { Code = "KeyE" }))" />
            </td>
        </tr>
        <tr>
            <td>
                <input id="A" type="button" disabled="@game.waitMovement" value="A @Char.ConvertFromUtf32(8592)" class="buttonsmovement" @onclick="@(e => KeyDown(new KeyboardEventArgs { Code = "KeyA" }))" />
            </td>
            <td>
                <input id="S" type="button" disabled="@game.waitMovement" value="S @Char.ConvertFromUtf32(8595)" class="buttonsmovement" @onclick="@(e => KeyDown(new KeyboardEventArgs { Code = "KeyS" }))" />
            </td>
            <td>
                <input id="D" type="button" disabled="@game.waitMovement" value="D @Char.ConvertFromUtf32(8594)" class="buttonsmovement" @onclick="@(e => KeyDown(new KeyboardEventArgs { Code = "KeyD" }))" />
            </td>
        </tr>
    </table>

    <pre class="map" @onkeydown="KeyDown" style="width: @(game.viewport.vpWidth)px;">
        @for (int y = game.map.mapCells.GetLength(1) - 1; y >= 0; y--)
        {
            for (int x = 0; x < game.map.mapCells.GetLength(0); x++)
            {
            <span class="@game.map.mapCells[x,y].cssClass">@game.map.mapCells[x,y].character</span>        
            }
            @Environment.NewLine
        }
    </pre>

</div>

@code {

    Game game;
    Logging logging;
    BrowserWindowSize browser = new BrowserWindowSize();

    protected override async Task OnInitializedAsync()
    {
        logging = new Logging()
            {
                logFile = configuration.GetValue<string>("BlazorDungeon3D:LogFile"),
                remoteIpAddress = httpContextAccessor.HttpContext.Connection.RemoteIpAddress.ToString(),
                userAgent = httpContextAccessor.HttpContext.Request.Headers["User-Agent"].ToString()
            };

        logging.Log(string.Format("New connection from IP:{0} User-Agent:{1}", logging.remoteIpAddress, logging.userAgent), logging.logFile);

        game = new Game();

        game.viewport.UpdateViewport(game.player, game.map);
        game.map.UpdateVisibleMap(game.player.curX, game.player.curY);
        game.map.UpdateCellMap(game.player.curX, game.player.curY, game.player.curDir);
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            // Subscribe to the OnResized event. This will do work when the browser is resized.
            listener.OnResized += WindowResized;
        }
    }

    protected async void KeyDown(KeyboardEventArgs e)
    {
        if (!game.waitMovement)
        {
            game.waitMovement = true;
            game.Move(e.Code);
            await Task.Delay(game.speed);
            game.waitMovement = false;
            StateHasChanged();
        }
    }

    protected async void WindowResized(object _, BrowserWindowSize window)
    {
        // Get the browsers's width / height
        browser = window;

        // We're outside of the component's lifecycle, be sure to let it know it has to re-render.
        StateHasChanged();
    }

    protected string CalculateTransformScale()
    {
        float clientWidth = 500;
        float clientHeight = 700;

        string scale = (1.0f / Math.Max(clientWidth / browser.Width, clientHeight / browser.Height)).ToString().Replace(",", ".");

        return scale;
    }
}